# Путеводитель по проекту "Наблюдатель Платформ" — объясняем на пальцах


---

## 1. `package.json` — Паспорт нашего проекта

Это как ID-карта нашего проекта. В этом файле описано, что за проект, какие у него есть зависимости, и как с ним работать.

### Что тут важно?

- `"name"` — это имя нашего проекта. Можно представить, что это имя твоей команды или компании.
- `"private": true` — очень важная штука! Она говорит: "Эй, этот проект не для того, чтобы его случайно отправили в публичный магазин npm". Это защищает нас от случайных ошибок.
- `"packageManager"` — здесь указано, какую версию менеджера пакетов (в нашем случае `pnpm`) использовать. Это как договориться, что все будут пользоваться одинаковым инструментом, чтобы не было проблем с разными версиями.
- `"type": "module"` — говорит, что мы используем современный стиль написания кода с `import` и `export`. Это как перейти с устаревших кассет на Spotify.

### Скрипты — наши команды

В `scripts` описаны команды, которые можно запускать в терминале:

- `"dev"` — запускает проект в режиме разработки. Это значит, что ты можешь быстро видеть изменения, которые делаешь в коде.
- `"build"` — собирает проект в готовый для запуска вид. Представь, что это упаковка твоего приложения в коробку.
- `"stop"` — просто выводит сообщение, что сервер остановлен. Удобно для контроля.
- `"docs:api"` — генерирует документацию по коду. Помогает понять, что делает каждая часть проекта.

### Зависимости — что нам нужно для работы

- `dependencies` — это пакеты, которые нужны, когда проект уже собран и запускается. Например, библиотеки, без которых приложение не заработает.
- `devDependencies` — инструменты, которые нужны только на этапе разработки: тесты, сборщики и прочее.

---

## 2. `turbo.json` — мозг нашего монорепозитория

Этот файл управляет тем, как мы запускаем задачи в проекте, особенно когда у нас несколько частей (пакетов), которые связаны между собой.

```json
{
  "$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true,
      "dependsOn": ["^dev"]
    }
  }
}
```

### Что тут происходит?

- `$schema` — техническая штука, которая помогает редактору подсказывать, если ты ошибаешься при редактировании.
- `tasks` — список задач, которые мы можем запускать.

#### Задача `build`

- `"dependsOn": ["^build"]` — это значит: "Перед тем как собирать этот пакет, сначала собери все его зависимости". Символ `^` — как стрелка, которая указывает на зависимости.
- `"outputs": ["dist/**"]` — говорит, что результат сборки лежит в папке `dist`. Turbo будет запоминать содержимое этой папки, чтобы не собирать заново, если ничего не изменилось.

#### Задача `dev`

- `"cache": false` — в режиме разработки мы не кэшируем результат, потому что хотим видеть изменения сразу.
- `"persistent": true` — говорит, что это задача, которая работает долго (например, сервер разработки).
- `"dependsOn": ["^dev"]` — перед запуском dev для этого пакета, запускает dev для зависимостей.

---

## 3. `pnpm-workspace.yaml` — список наших проектов

Этот файл говорит `pnpm`, какие папки в нашем репозитории являются отдельными проектами.

```yaml
packages:
  - 'packages/*'
  - 'admin'
  - 'backend'
```

- `'packages/*'` — значит, что все папки внутри `packages/` (например, `core`, `ui`) — это отдельные части проекта.
- `'admin'` и `'backend'` — тоже отдельные проекты, которые лежат в корне.

Это похоже на список всех комнат в большом доме, чтобы знать, где что находится.

---

## 4. `tsconfig.json` — правила для нашего TypeScript

Этот файл задаёт настройки для компилятора TypeScript — инструмента, который превращает наш код в понятный для компьютера формат.

### Основные настройки (`compilerOptions`):

- `"target": "ESNext"` — говорит, что мы хотим использовать самые современные возможности JavaScript.
- `"module": "NodeNext"` — указывает, как обрабатывать модули, чтобы работать с новым стилем `import/export`.
- `"lib": ["ESNext", "DOM"]` — добавляет поддержку новых функций JS и браузерных API.
- `"strict": true` — включает строгую проверку кода. Это помогает ловить ошибки раньше.
- `"esModuleInterop": true` — облегчает работу с разными типами модулей.
- `"skipLibCheck": true` — пропускает проверку типов в библиотеках, чтобы ускорить сборку.
- `"forceConsistentCasingInFileNames": true` — заставляет использовать одинаковый регистр в названиях файлов, чтобы избежать проблем на разных ОС.
- `"moduleResolution": "NodeNext"` — определяет, как искать модули.

### Структура проекта (`references`):

- `"files": []` — говорит, что этот файл не компилирует код напрямую.
- `"references"` — список под-проектов, которые входят в наш монорепозиторий:
  - `admin`
  - `backend`
  - `packages/core`
  - `packages/ui`

Это как карта, которая показывает, из каких частей состоит наш большой проект.

---

## 5. `typedoc.json` — настройки для создания документации

Этот файл настраивает `TypeDoc` — инструмент, который автоматически создаёт документацию по нашему коду.

```json
{
  "entryPoints": [
    "packages/core/src/index.ts",
    "packages/ui/src/index.ts"
  ],
  "out": "docs/api",
  "tsconfig": "tsconfig.json",
  "disableSources": true,
  "includeVersion": true
}
```

### Что здесь важно?

- `"entryPoints"` — главные файлы, с которых начинается сбор документации. Обычно это точки входа в наши пакеты.
- `"out"` — папка, куда положится сгенерированная документация.
- `"tsconfig"` — какой конфиг TypeScript использовать при генерации.
- `"disableSources": true` — не включать исходный код в документацию, чтобы она была чище.
- `"includeVersion": true` — добавлять версию проекта в документацию, чтобы знать, к какой версии относится документация.

---

# Часть 2: Папка `admin` — Пульт Управления

Здесь находится фронтенд-проект админ-панели. Это отдельное React-приложение, которое собирается с помощью `Vite`.

## 7. `admin/package.json` — Паспорт Админки

Этот файл описывает скрипты и зависимости, необходимые *только для админ-панели*.

### 7.1. Скрипты (`scripts`)

*   `"dev": "vite"`: Запускает локальный сервер для разработки админки с горячей перезагрузкой.
*   `"build": "tsc -b && vite build"`: **Очень важная команда сборки.** Она состоит из двух частей:
    1.  `tsc -b`: Сначала запускается компилятор TypeScript для проверки всех типов в проекте.
    2.  `&& vite build`: Если проверка типов прошла успешно, `Vite` собирает проект в готовую для продакшена версию (в папку `dist`).
*   `"lint": "eslint ."`: Запускает проверку кода на соответствие стандартам (стиль, возможные ошибки).
*   `"preview": "vite preview"`: Позволяет посмотреть локально, как будет выглядеть *собранная* версия проекта.

### 7.2. Зависимости (`dependencies`)

Это "детали", из которых состоит админка.

*   `axios`: Наш "почтальон" для отправки запросов на бэкенд.
*   `react-router-dom`: Отвечает за навигацию по страницам внутри админки.
*   `jwt-decode`: Инструмент для расшифровки JWT-токенов (для работы с авторизацией).
*   `lucide-react`: Библиотека красивых иконок.
*   `clsx`, `class-variance-authority`, `tailwind-merge`: Трио утилит для удобной и гибкой работы со стилями в Tailwind CSS.

### 7.3. Зависимости для разработки (`devDependencies`)

Это "инструменты", которые нужны только для сборки и разработки админки.

*   `vite`, `@vitejs/plugin-react`: Сам сборщик `Vite` и плагин для работы с React.
*   `tailwindcss`, `postcss`, `autoprefixer`: Инструменты для стилизации с помощью Tailwind CSS.
*   `eslint` и плагины: Инструменты для поддержания чистоты и качества кода.
*   `typescript`: Компилятор TypeScript.

---

 

## 8. `admin/vite.config.ts` — Инструкция по Сборке Админки

Это главный конфигурационный файл для `Vite` — инструмента, который собирает наше React-приложение и обеспечивает локальный сервер для разработки.

```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
```

`plugins: [react()]`: Подключает официальный плагин от Vite для работы с React. Он отвечает за "магию" горячей перезагрузки (HMR) и правильную обработку JSX.  
`resolve.alias`: Очень важная секция для удобства разработки. Она создает "псевдоним" (алиас).  
`"@": path.resolve(__dirname, "./src")`: Эта строка говорит: "Символ @ теперь всегда будет означать путь к папке src". Это позволяет нам писать чистые и красивые импорты, не задумываясь, на каком уровне вложенности мы находимся. Например: `import api from '@/lib/api'` вместо `../../../lib/api`.


## 9. `admin/tsconfig.json` — Локальный "Дирижер" TypeScript

Этот `tsconfig.json` отличается от корневого. Он не содержит всех правил, а выступает в роли "дирижера" или "диспетчера" для других, более специфичных конфигов внутри админки.

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
```

- `"references"`: Ключевая секция. Она говорит TypeScript, что данный проект состоит из двух частей:
  - `tsconfig.app.json`: правила для кода самого приложения (в браузере).
  - `tsconfig.node.json`: правила для конфигов (в Node.js).
- `"paths"`: Повторяет alias-настройку для редактора и TypeScript, чтобы работали импорты с `@`.


## 10. `admin/tsconfig.app.json` — Правила для Кода Приложения

Это основной файл с правилами для TypeScript, который отвечает за код внутри папки `src`.

```json
{
  "extends": "./tsconfig.json",
  "include": ["src"]
}
```

- `"extends"`: Наследует правила из `tsconfig.json`.
- `"include"`: Применяет их только к `src`.

**Ключевые параметры (в других местах):**

- `"lib"`: `["ES2022", "DOM"]` — позволяет использовать возможности браузера и современный JS.
- `"jsx": "react-jsx"`: корректная работа с JSX.
- `"noEmit": true`: TypeScript только проверяет код, а сборку делает Vite.
- `"strict": true`, `"noUnusedLocals"` и пр.: строгие проверки для качественного кода.


## 11. `admin/tsconfig.node.json` — Правила для Конфигурационных Файлов

Файл `tsconfig.node.json` используется только для конфигураций, исполняемых в Node.js (например, `vite.config.ts`).

```json
{
  "include": ["vite.config.ts"],
  "compilerOptions": {
    "lib": ["ES2023"],
    "paths": {
      "@scripts/*": ["../scripts/*"]
    }
  }
}
```

- `"include"`: Применяется только к `vite.config.ts`.
- `"lib"`: Нет `DOM`, потому что в Node нет `window` и `document`.
- `"paths"`: Удобный псевдоним `@scripts/*` для импорта скриптов из `../scripts`.


## 12. `admin/tailwind.config.js` — Палитра и Шрифты Проекта

Этот файл — это "дизайн-бюро" нашей админки. Здесь мы настраиваем `Tailwind CSS`, определяя все цвета, шрифты, отступы и другие визуальные элементы, чтобы поддерживать единый стиль во всем приложении.

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {
      colors: {
        brand: { primary: "var(--brand-primary)" },
        // ...
      },
      fontFamily: {
        sans: ["var(--font-manrope)", "sans-serif"],
        // ...
      },
    },
  },
  plugins: [],
};
```

### Пояснения:

- **content**: Ключевая опция для производительности. Указывает Tailwind, какие файлы нужно "сканировать" в поисках используемых классов. В итоговый CSS-файл попадут стили только для тех классов, которые найдены в этих файлах. Это делает финальный CSS очень маленьким и быстрым.
- **theme.extend**: Здесь мы расширяем стандартную тему Tailwind своими кастомными значениями.
- **colors и fontFamily**: Наш проект использует очень мощный подход, связывая цвета и шрифты Tailwind с CSS-переменными (например, var(--brand-primary)). Это значит, что фактические значения цветов (#FFFFFF, rgb(0,0,0)) задаются в глобальном файле стилей (например, src/index.css). Такой подход невероятно упрощает смену тем (например, добавление темной темы).
- **plugins**: Сюда можно подключать дополнительные плагины для Tailwind, которые расширяют его возможности (например, для более красивых форм или типографики).


## 13. `admin/postcss.config.cjs` — Финальная Обработка Стилей

Этот файл настраивает `PostCSS` — инструмент, который выступает в роли "сборочного конвейера" для наших CSS-стилей. Он обрабатывает CSS после того, как его сгенерировал `Tailwind`.

```javascript
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
};
```

**Пояснения:**

- `'@tailwindcss/postcss'`: Основной плагин, который и является движком Tailwind CSS.
- `autoprefixer`: "Мастер по совместимости". Он автоматически добавляет к стилям специальные префиксы (например, `-webkit-`), чтобы обеспечить одинаковое отображение нашего сайта во всех популярных браузерах.


## 14. `src/main.tsx` — Ключ Зажигания Приложения

Это самый первый файл, который выполняется при запуске админки. Его задача — "вмонтировать" наше React-приложение в HTML-страницу.

```tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.tsx";

// ... (информационное сообщение в консоли)

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

**Импорты:**  
Сначала мы импортируем всё необходимое:  
**StrictMode** — для включения режима "диагностики" от React.  
**createRoot** — современная функция для запуска приложения.  
**./index.css** — критически важный импорт, который подключает все глобальные стили и CSS-переменные.  
**App** — наш корневой компонент.

**Запуск:**  
Команда `createRoot(...).render(...)` находит в `index.html` элемент с `id="root"` и отрисовывает в нем всё наше приложение, обернутое в `<StrictMode>`.


## 15. `src/App.tsx` — Главный Навигатор Приложения

Этот файл работает как "карта дорог" или "главный навигатор" для всей админки. Он не содержит видимых элементов, а только определяет, какую страницу показывать пользователю в зависимости от URL-адреса в браузере.

```tsx
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<LoginPage />} />
        <Route element={<Layout />}>
          <Route path="/" element={<SitesPage />} />
          {/* ... другие страницы */}
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

### Объяснение:

- `<BrowserRouter>`: Главная "обертка", которая включает систему навигации для всего приложения.
- `<Routes>`: Работает как "переключатель". Он смотрит на текущий URL и выбирает первый совпавший маршрут `<Route>`.
- **Вложенные маршруты (Layout Route)**: Это ключевая особенность нашего приложения.
  - `<Route path="/login" ... />` — это обычный маршрут, который ведет на страницу входа.
  - `<Route element={<Layout />}> ... </Route>` — это маршрут-каркас. Он говорит: "Для всех маршрутов, которые находятся внутри меня, сначала отобрази компонент Layout (с шапкой и меню), а уже внутри Layout отображай нужную страницу (SitesPage, UsersPage и т.д.)". Это позволяет нам иметь единый внешний вид для всех страниц админки.


## 16. `src/index.css` — Глобальные Стили и Дизайн-Система

Этот файл — фундамент всего внешнего вида нашего приложения. Он не просто задает стили, а определяет нашу централизованную дизайн-систему.

```css
/* Подключение "движка" Tailwind */
@import "tailwindcss/preflight";
@tailwind utilities;

/* Определение палитры */
@layer base {
  :root {
    --brand-primary: #6B80C5;
    /* ... и другие переменные */
  }
}
```

### Пояснения

- **Импорты Tailwind**: Мы подключаем `preflight` (сброс стилей для консистентности) и `utilities` (все классы Tailwind).
- **@layer**: Эта директива помогает управлять порядком применения стилей, чтобы избежать конфликтов.
- **:root и CSS Переменные**: Это сердце нашей дизайн-системы.
- **Связь с tailwind.config.js**: Это работает в паре. В `tailwind.config.js` мы даем цветам имена (например, `brand-primary`). А здесь, в `index.css`, мы даем этим именам реальные значения с помощью CSS-переменных (например, `--brand-primary: #6B80C5;`). Этот подход делает смену темы (например, на темную) невероятно простой задачей — достаточно поменять значения переменных в одном месте.
- **Стили для body**: В конце файла мы применяем наши переменные к `<body>`, задавая базовый шрифт и цвета для всего приложения.


## 17. `src/components/Layout.tsx` — "Каркас" и "Охранник" Приложения

Этот компонент — один из самых умных и важных в админке. Он выполняет две ключевые функции:

1.  **"Каркас" (UI Shell):** Он создает общий внешний вид для всех страниц — шапку с навигацией и подвал. Внутри него есть "портал" (`<Outlet />`), куда `React Router` вставляет контент конкретной страницы.
2.  **"Охранник" (Auth Guard):** Он проверяет, авторизован ли пользователь. Если в `localStorage` нет валидного JWT-токена, он немедленно перенаправляет пользователя на страницу `/login`.

### Ключевые особенности логики:

*   **Проверка токена:** При каждой загрузке страницы `Layout` проверяет наличие и валидность токена. Если токен невалиден, он удаляется, и пользователь отправляется на логин.
*   **Динамическая навигация:** Меню в шапке строится динамически. Например, ссылка на страницу "Настройки" появляется только в том случае, если у пользователя в токене указана роль `superadmin`.
*   **Логика выхода:** Кнопка "Выйти" очищает токен из `localStorage` и перенаправляет на страницу входа.
*   **Экран загрузки:** Пока идет проверка токена, пользователю отображается "Загрузка...", что улучшает пользовательский опыт.

> **📝 Заметка на будущее (потенциальное улучшение):**
> Сейчас этот компонент совмещает две роли: он и "каркас", и "охранник". В будущем, по мере роста проекта, эту логику можно будет разделить для большей чистоты кода. Например, можно создать отдельный компонент `ProtectedRoute.tsx`, который будет отвечать **только** за проверку авторизации, а `Layout.tsx` будет отвечать **только** за внешний вид. Это сделает систему еще более гибкой и понятной.



---

## 18. `src/pages/SitesPage.tsx` — Страница-Комбайн для Управления Сайтами

Это классический пример страницы, которая реализует CRUD-логику (Create, Read, Update, Delete). Она загружает данные с сервера, отображает их в виде таблицы и позволяет пользователю взаимодействовать с этими данными.

### Ключевые паттерны и практики:

*   **Три состояния (`loading`, `error`, `data`):** Компонент управляет тремя состояниями: идет ли сейчас загрузка, произошла ли ошибка, или данные успешно получены. В зависимости от этого, он показывает пользователю либо спиннер, либо сообщение об ошибке, либо таблицу с данными. Это обеспечивает отличный пользовательский опыт (UX).
*   **Запрос данных при загрузке:** Используется `useEffect` с пустым массивом зависимостей `[]` для вызова функции `fetchSites` ровно один раз, когда компонент монтируется на страницу.
*   **Оптимистичное обновление UI (Optimistic UI Update):** После изменения статуса сайта (`handleToggleStatus`), мы не перезагружаем весь список с сервера. Вместо этого мы немедленно обновляем состояние `sites` локально. Это делает интерфейс очень быстрым и отзывчивым, так как пользователю не нужно ждать ответа от сервера, чтобы увидеть результат своих действий.

> **📝 Заметка на будущее (потенциальное улучшение):**
> 1.  **Централизация API-запросов:** Логика отправки запросов (`fetch`) и обработки токена сейчас дублируется в нескольких местах. В будущем это можно вынести в один централизованный "API-клиент" (например, в файл `src/lib/api.ts`). Это упростит код и сделает его более надежным.
> 2.  **Переменные окружения:** Адрес бэкенда (`http://localhost:3001`) сейчас "захардкожен". Его следует вынести в переменные окружения (файл `.env`), чтобы легко менять его для разработки и продакшена.
> 3.  **Динамический маршрут:** Кнопка "Управление" пытается перейти по адресу `/sites/${site.id}`, но такой динамический маршрут (`/sites/:id`) еще не зарегистрирован в `App.tsx`. Его нужно будет добавить.

## 19. `src/pages/sites/Kyanchir.tsx` — Командный Центр Сайта

Эта страница — это детальный "пульт управления" для одного конкретного сайта. В отличие от страницы со списком, здесь мы управляем внутренним контентом: баннерами, товарами и т.д.

### Ключевые особенности:

- **Интерфейс с вкладками (Tabs):** Используется локальное состояние (`useState`) для переключения между разными разделами управления (`Контент`, `Товары`, `Пользователи`), что позволяет не перегружать интерфейс.
- **Редактор контента:** На вкладке "Контент" реализована форма для редактирования баннера с полями ввода, предпросмотром изображения и кнопками для сохранения и предпросмотра.
- **Прямое взаимодействие с API:** Компонент напрямую отправляет запросы на бэкенд для сохранения изменений.
- **Композиция компонентов:** Страница выступает в роли "контейнера" для других, более специализированных редакторов (`ProductCardsEditor`, `UsersEditor`).

> **📝 Заметка на будущее (потенциальное улучшение):**
> Этот компонент — отличный кандидат на будущий **рефакторинг** (улучшение структуры).
> 1. **Динамика вместо статики:** Сейчас компонент "жестко" привязан к сайту "Kyanchir". В идеале, он должен быть **динамическим**. То есть, должен существовать один компонент `SiteEditorPage.tsx`, который бы получал ID сайта из URL (`/sites/:siteId`) и загружал/сохранял контент для любого сайта.
> 2. **Декомпозиция:** Логику редактора баннера (состояние, JSX, функции) можно вынести в собственный компонент `BannerEditor.tsx`, чтобы очистить код основной страницы.
> 3. **Централизация API и .env:** Как и на других страницах, логику `fetch` и "зашитые" URL-адреса стоит вынести в центральный API-клиент и файлы окружения (`.env`).
> 4. **Система уведомлений:** Заменить `alert()` на более современную систему "тост"-уведомлений.


## 20. `src/components/AuthLayout.tsx` — "Сцена" для Страниц Авторизации

Это простой, но очень важный компонент-обертка. Его единственная задача — создать "сцену" для страниц, связанных с авторизацией (например, для страницы входа). Он берет любой дочерний элемент и размещает его идеально по центру экрана на нейтральном фоне.

```tsx
export default function AuthLayout({ children }) {
  return (
    <div className="min-h-screen flex items-center justify-center ...">
      {children}
    </div>
  );
}
```

- Принцип единственной ответственности: Этот компонент не занимается логикой, не запрашивает данные. Он только предоставляет стилизованную "обертку".
- Центрирование с Flexbox: Используется классический набор классов flex items-center justify-center, чтобы гарантировать идеальное центрирование контента на любом экране.
- Переиспользование: Мы можем использовать этот AuthLayout для любой страницы, которую нужно центрировать — будь то страница входа, регистрации, восстановления пароля и т.д., обеспечивая единый внешний вид.


## 21. `src/components/ProtectedRoute.tsx` — «Чистый Охранник» для Маршрутов

Этот компонент реализует паттерн "Auth Guard" в его чистом виде. Его единственная задача — проверять наличие токена авторизации и либо разрешать доступ к дочерним маршрутам, либо перенаправлять на страницу входа.

```tsx
export default function ProtectedRoute() {
  const token = localStorage.getItem("token");

  if (!token) {
    return <Navigate to="/login" replace />;
  }

  return <Outlet />;
}
```

- Принцип единственной ответственности: Этот компонент не занимается отображением UI (кроме редиректа). Он делает только одну вещь — защищает маршруты.
- Декларативный редирект: Используется компонент `<Navigate>` из React Router для перенаправления. Это более современный и "реактивный" способ, чем использование useNavigate.
- Использование `<Outlet />`: Если проверка пройдена, компонент рендерит `<Outlet />`, который служит "порталом" для вложенного маршрута (т.е. для той страницы, которую мы защищаем).

> 📝 Заметка по внедрению:
> На данный момент этот компонент создан, но еще не используется в App.tsx. Логика проверки авторизации пока что находится внутри Layout.tsx. Внедрение этого компонента будет следующим шагом по улучшению архитектуры. Он позволит отделить логику защиты доступа от логики отображения "каркаса" сайта.


## 22. `src/lib/utils.ts` — "Швейцарский Нож" для Стилей

Этот файл содержит вспомогательные утилиты, и главная из них — функция `cn`.

### Функция `cn`

`cn` (сокращение от `className`) — это мощная утилита, которая решает проблему конфликта CSS-классов в переиспользуемых компонентах. Она является комбинацией двух библиотек: `clsx` и `tailwind-merge`.

- **Как это работает:**
  1. **`clsx`** сначала собирает все переданные классы (включая условные) в одну строку.
  2. Затем **`tailwind-merge`** "прочесывает" эту строку и разрешает конфликты. Например, если в строке есть и `p-2`, и `p-4`, `tailwind-merge` оставит только `p-4`.

- **Зачем это нужно?** Это позволяет создавать гибкие компоненты. Мы можем задать компоненту стили по умолчанию, но при этом разрешить пользователю передавать свои собственные классы для кастомизации, и быть уверенными, что они не "сломают" друг друга. Это стандартная практика в современных UI-библиотеках.


## 23. `.../BannerEditor.tsx` — Продвинутый Редактор с Автосохранением

Этот компонент является отличным примером "умного" редактора, вынесенного в отдельный модуль. Он отвечает только за управление баннером.

### Ключевые паттерны и практики:

- **Автосохранение (Debounce):** Главная "фишка" компонента. Используется связка `useEffect` и `setTimeout` для реализации "отложенного" сохранения. Запрос на сервер отправляется не на каждое нажатие клавиши, а только после того, как пользователь прекратил ввод на определенное время (1.2 секунды). Это значительно снижает нагрузку на сервер.
- **Разделение состояний `draft` и `published`:** Компонент хранит в памяти и черновик, с которым работает пользователь, и последнюю опубликованную версию. Это позволяет сравнивать изменения и дает пользователю больше контроля.
- **Индикатор статуса:** Пользователь в реальном времени видит статус сохранения (`saving`, `saved`, `error`), что улучшает UX.

> **📝 Заметка на будущее (потенциальное улучшение):**
> Этот компонент, как и его родитель, является идеальным кандидатом для рефакторинга в сторону **переиспользуемости**. Сейчас он "жестко" привязан к `siteId="kyanchir"`. В будущем он должен будет получать `siteId` через пропсы, чтобы его можно было использовать для редактирования баннера на **любом** сайте, а не только на одном.


## 24. `.../ProductCardsEditor.tsx` — Редактор Списка Товаров

Этот компонент — это полноценный "сборочный цех" для управления списком однотипных данных, таких как карточки товаров.

### Ключевые паттерны и практики:

- **Управление массивом в состоянии:** Компонент хранит весь список товаров в состоянии (`useState<Product[]>`) и предоставляет функции для его изменения (`handleAdd`, `handleDelete`, `handleChange`).
- **Иммутабельность:** Все операции по изменению списка (добавление, удаление, редактирование) выполняются через создание **копии** массива. Это фундаментальный и очень важный принцип в React, который гарантирует предсказуемое поведение и рендеринг.
- **Сохранение "пачкой":** В отличие от автосохранения отдельных полей, здесь используется ручное сохранение, которое отправляет на сервер весь массив товаров целиком. Это простой и надежный подход для управления черновиками.
- **Обратная связь для пользователя:** Кнопка "Сохранить" блокируется и меняет текст во время отправки запроса, давая пользователю понять, что процесс идет.
- **Клиентская генерация ID:** Для новых, еще не сохраненных элементов используется `Date.now()` для генерации временного ID. Это необходимо для корректной работы `key` в React.

> **📝 Заметка на будущее (потенциальное улучшение):**
> Как и другие редакторы, этот компонент можно сделать более универсальным и надежным:
> 1. **Переиспользуемость:** Сделать `siteId` получаемым извне (через пропсы).
> 2. **Надежные ID:** Заменить `Date.now()` на библиотеку `uuid` для генерации уникальных клиентских ID, чтобы избежать возможных коллизий.
> 3. **Поэлементное сохранение:** Для очень больших списков или систем с несколькими редакторами можно будет перейти от сохранения "пачкой" к отправке на сервер отдельных команд: "добавь товар X", "удали товар Y", "обнови поле Z у товара W".


## 25. `.../UsersEditor.tsx` — Компонент-Заглушка (Placeholder)

Этот компонент является примером **"заглушки" (placeholder)**. Это стандартная практика в разработке, когда UI для какой-то функциональности уже спроектирован (например, есть вкладка "Пользователи"), но сама логика еще не реализована.

Такой компонент не делает ничего, кроме отображения информационного сообщения. Он полезен, так как:
1. Позволяет избежать ошибок и "падения" приложения при переключении на нереализованную вкладку.
2. Служит "напоминанием" и "планом" для дальнейшей разработки.

В отличие от "мусора" (старых, неиспользуемых файлов), "заглушки" являются частью плана разработки и удаляются только после того, как на их месте появляется реальный функционал.

## 26. `src/pages/LoginPage.tsx` — "Пропускной Пункт"

Эта страница — "ворота" в нашу админ-панель. Она представляет собой стандартную форму входа, которая взаимодействует с бэкендом для аутентификации пользователя.

### Ключевые особенности:

- **Управляемая форма:** Компонент использует useState для полного контроля над значениями в полях ввода и для отображения сообщений об ошибках.
- **Использование Layout:** Форма обернута в AuthLayout, который обеспечивает ее красивое центрирование на странице.
- **Логика аутентификации:**
  - При отправке формы данные уходят на эндпоинт `/api/auth/login`.
  - В случае успеха, полученный JWT-токен сохраняется в localStorage браузера.
  - После успешного сохранения токена, пользователь программно перенаправляется (navigate) внутрь защищенной части приложения.
  - В случае ошибки (неверный пароль, ошибка сервера), ее текст отображается над формой.
- **Хорошие практики UX/Accessibility:** В форме используются `<label>`, `required` и `autoComplete`, что улучшает как пользовательский опыт, так и доступность.

> 📝 Заметка на будущее (потенциальное улучшение):
> Как и другие компоненты, работающие с API, логику fetch и адрес бэкенда стоит вынести в централизованный API-клиент и переменные окружения (.env) для большей чистоты и гибкости.


## 27. `src/pages/SettingsPage.tsx` — Страница-Заглушка

Этот компонент, как и `UsersEditor`, является **"заглушкой" (placeholder)**. Он используется для маршрута `/settings`, который доступен только `superadmin`.

Он не содержит никакой логики и просто выводит информационное сообщение. Это позволяет нам построить навигацию и структуру приложения, даже если не все разделы еще готовы.


## 28. `src/pages/Users.tsx` — "Божественный Компонент" Управления Пользователями

Эта страница — самый сложный и многофункциональный компонент в админ-панели на данный момент. Он реализует полный CRUD (Create, Read, Update, Delete) для пользователей, а также загрузку файлов, inline-редактирование, фильтрацию и сортировку.

### Ключевые паттерны и практики:

- **"God Component":** Компонент управляет огромным количеством состояний (`useState`) и содержит всю логику для всех операций, что делает его сложным для поддержки.
- **Inline-редактирование:** Позволяет менять данные пользователя (имя, email, роль) прямо в списке, без перехода на отдельную страницу.
- **Предупреждение о несохраненных изменениях:** Используется `useRef` и `beforeunload` event, чтобы предупредить пользователя, если он пытается закрыть страницу, не сохранив изменения.
- **Клиентская фильтрация и сортировка:** Вся логика поиска и сортировки происходит в браузере.
- **Загрузка файлов:** Реализована логика для загрузки аватаров на сервер и обновления данных пользователя.

> **📝 Заметка на будущее (Крупный Рефакторинг):**
> Этот компонент — главный кандидат на **масштабный рефакторинг** в будущем для повышения его надежности и упрощения поддержки.
> 1. **Декомпозиция:** Разбить "монстра" на мелкие, независимые компоненты:
>    - `AddUserForm.tsx` (форма добавления).
>    - `UserListItem.tsx` (один элемент списка со своей логикой inline-редактирования).
>    - `ChangePasswordModal.tsx` (модальное окно смены пароля).
>    - `UserFilters.tsx` (компонент для фильтрации и сортировки).
> 2. **Централизация API:** Вынести всю логику `fetch` в единый API-клиент.
> 3. **Переход на серверную пагинацию:** Для масштабируемости, перенести логику фильтрации, сортировки и загрузки порциями (пагинации) на бэкенд.
> 4. **Внедрение State Manager:** Для таких сложных страниц в будущем можно будет рассмотреть использование библиотеки для управления состоянием (Zustand, Redux Toolkit), чтобы не хранить 20 `useState` в одном компоненте.


 

## 31. `src/vite-env.d.ts` — "Словарь" для TypeScript

Это файл **объявлений типов**. Его задача — "объяснить" TypeScript-у, как работать со специфическими возможностями, которые предоставляет `Vite` в браузере.

- **`/// <reference types="vite/client" />`**: Эта директива подключает "словарь", который описывает типы для Vite-специфичных переменных, например `import.meta.env`. Без этого файла TypeScript считал бы использование таких переменных ошибкой.
- **Важно:** Этот файл обычно генерируется автоматически и не требует ручного редактирования.

## 32. Файлы `.gitignore` — "Списки-Невидимки"

В проекте используется два файла `.gitignore`. Это стандартная и очень правильная практика для монорепозиториев, позволяющая разделить глобальные и локальные правила игнорирования.

### 32.1. `/.gitignore` (в корне)

Это **главный "устав"**, который действует на весь проект. Он содержит глобальные правила для Git, говоря ему игнорировать:
*   **Зависимости и кэш:** Все папки `node_modules`, `dist`, `.turbo` и т.д.
*   **Логи:** Любые файлы логов.
*   **Системный "мусор":** Файлы типа `.DS_Store`.
*   **Файлы с секретами:** **Самое важное правило** — `*.env*`. Оно предотвращает попадание паролей и ключей API в репозиторий.
*   **Данные проекта:** **Критически важные правила** `backend/db/*.json` и `backend/uploads/` запрещают Git отслеживать локальную базу данных и загруженные пользователями файлы, что предотвращает конфликты и утечку данных.

### 32.2. `/admin/.gitignore` (локальный)

Этот файл добавляет **специфичные правила, которые действуют только внутри папки `admin`**. После нашей чистки он содержит только уникальные для админки правила. Самое интересное из них:

```gitignore
.vscode/*
!.vscode/extensions.json

---

## 33. `admin/components.json` — Чертеж для UI-Компонентов (shadcn/ui)

Этот файл является конфигурацией для **`shadcn/ui`** — инструмента, который мы используем для добавления UI-компонентов (кнопки, поля ввода, диалоговые окна и т.д.) в наш проект.

**Это не обычная библиотека, а "копировщик" кода.** Когда мы запускаем команду `npx shadcn-ui@latest add button`, он не устанавливает зависимость, а копирует исходный код компонента прямо в наш проект.

### Роль `components.json`

Этот файл — это "инструкция" для этого "копировщика". Он говорит ему:
*   **Где находятся наши стили** (`tailwind.config.js`, `src/index.css`), чтобы новые компоненты сразу выглядели правильно.
*   **Какие пути использовать** (`aliases`). Благодаря этому, сгенерированный код сразу использует наши красивые пути, например, `@/lib/utils` для функции `cn`.
*   **Какую библиотеку иконок** использовать по умолчанию (`lucide`).

Это очень мощный инструмент, который сильно ускоряет разработку UI, сохраняя при этом полный контроль над кодом компонентов.

---

## 34. `admin/eslint.config.js` — "Надзиратель" за Качеством Кода

Этот файл является конфигурацией для **`ESLint`** — нашего главного инструмента для статического анализа кода. Его задача — автоматически находить проблемы в коде, такие как потенциальные ошибки, нарушение стиля или использование плохих практик.

Этот конфиг написан в новом "плоском" формате (ESLint v9+).

### Что он делает:

*   **`globalIgnores`**: Говорит ESLint игнорировать определенные папки. В нашем случае это папка `dist`, так как проверять скомпилированный код не имеет смысла.
*   **`files`**: Указывает, что правила будут применяться только к файлам TypeScript (`.ts` и `.tsx`).
*   **`extends`**: Это "сердце" конфига. Здесь мы подключаем готовые наборы правил:
    *   **Базовые правила:** от `eslint` и `typescript-eslint`.
    *   **Правила для React:** `eslint-plugin-react-hooks` следит за правильным использованием хуков (`useState`, `useEffect`), что предотвращает множество багов.
    *   **Правила для Vite:** `eslint-plugin-react-refresh` обеспечивает корректную работу "горячей перезагрузки" (HMR).
*   **`languageOptions`**: Сообщает ESLint, что наш код выполняется в среде браузера, поэтому глобальные переменные вроде `window` или `document` не должны вызывать ошибок.
---

## 35. `admin/index.html` — "Сцена" для Приложения

Это единственный HTML-файл в нашем React-приложении. Он служит "скелетом" или "сценой", на которую `Vite` и `React` "монтируют" всё наше приложение.

### Ключевые элементы:

*   **`<head>`**: Содержит все метаданные: кодировку, заголовок страницы и, что очень важно, **оптимизированный способ загрузки шрифтов**.
    *   **Оптимизация шрифтов:** Используется техника с `rel="preload"`, которая позволяет браузеру начать загрузку шрифтов заранее, не блокируя при этом отображение остальной части страницы. Это улучшает воспринимаемую скорость загрузки сайта.

*   **`<body>`**: Содержит два критически важных элемента:
    *   `<div id="root"></div>`: Это пустой контейнер, "сцена". React находит этот элемент по его `id` и вставляет внутрь него всё наше приложение.
    *   `<script type="module" src="/src/main.tsx"></script>`: Эта строка подключает наш главный JavaScript-файл, который и запускает всю логику React.

    Разбор структуры backend
Давай быстро пробежимся по "отсекам" нашего "машинного отделения":
db/: "Хранилище данных". Здесь лежат наши JSON-файлы, которые выступают в роли простой базы данных.
routes/: "Телефонная станция". Здесь описаны все URL-адреса (эндпоинты), на которые может "звонить" наша админка.
middlewares/: "Служба безопасности". Это "охранники", которые стоят перед каждым эндпоинтом и проверяют "пропуск" (токен), права доступа и т.д.
config/: "Панель настроек". Здесь лежат конфигурационные файлы для разных частей бэкенда (например, для загрузки файлов).
uploads/: "Склад". Сюда складываются все файлы, которые загружают пользователи. (Мы уже сказали Git игнорировать эту папку).
index.ts: "Главный рубильник". Файл, который запускает весь сервер.
package.json и tsconfig.json: Наши старые знакомые — "паспорт" и "учебник" для бэкенда.

---
---

# Часть 3: Папка `backend` — "Двигатель" Проекта

Здесь находится "сердце" нашего приложения — серверная часть. Это Node.js приложение, написанное на TypeScript с использованием фреймворка Express. Оно отвечает за всю работу с данными, авторизацию и бизнес-логику.

## 38. `backend/package.json` — Паспорт Бэкенда

Этот файл описывает "детали", из которых собран наш "двигатель".

### 38.1. Скрипты (`scripts`)
*   `"dev": "tsx index.ts"`: Запускает сервер в режиме разработки. `tsx` — это инструмент, который позволяет запускать TypeScript-код напрямую, без предварительной компиляции, и автоматически перезапускать сервер при изменениях в коде.

### 38.2. Зависимости (`dependencies`)
Это "ключевые детали" нашего "двигателя".

*   `express`: **"Шасси" или "каркас" нашего сервера.** Это минималистичный веб-фреймворк, на котором всё построено.
*   `cors`: **"Политика гостеприимства".** Позволяет нашему фронтенду (админке) безопасно "общаться" с бэкендом, даже если они запущены на разных адресах (портах).
*   `jsonwebtoken`: **"Мастерская по созданию пропусков".** Библиотека для создания и проверки JWT-токенов.
*   `bcryptjs`: **"Шифровальная машина"** для паролей.
*   `multer`: **"Служба доставки"**, которая умеет принимать файлы, загруженные из админки.
*   `uuid`: **"Генератор уникальных номеров"** для создания ID.

### 38.3. Зависимости для разработки (`devDependencies`)
Это "инструменты для механиков".

*   `@types/*`: Набор "чертежей" (файлов с типами) для всех наших библиотек, чтобы TypeScript их "понимал".
*   `tsx`: Тот самый инструмент для "горячего" запуска TypeScript-кода.
*   `typescript`: Сам язык TypeScript.

---

## 39. `backend/index.ts` — "Главный Рубильник" Сервера

Это основной файл, который запускает весь наш бэкенд. Он работает как "главный сборочный цех", который собирает все части "двигателя" вместе и запускает их.

### Ключевые этапы работы:

1.  **Инициализация:** Создается экземпляр `Express`-приложения.
2.  **Настройка CORS:** Задается "политика гостеприимства". Наш конфиг очень гибкий: он разрешает запросы только с определенных, "белых" доменов (`localhost`, домен админки, домен клиентского сайта).
3.  **Подключение "помощников" (Middlewares):**
    *   `express.json()`: "Переводчик", который учит наш сервер понимать JSON-формат.
    *   `express.static()`: Создает "публичную папку" для раздачи загруженных файлов.
4.  **Регистрация "Телефонной Станции" (Маршрутов):**
    *   Все файлы из папки `routes/` импортируются и "подключаются" к приложению.
    *   Маршруты разделены на **публичные** (не требуют "пропуска") и **защищенные** (требуют "пропуска"). Защищенные маршруты используют "охранника" `requireAuth`.
5.  **Обработка 404:** Регистрируется обработчик для всех неизвестных маршрутов.
6.  **Запуск Сервера:** Команда `app.listen()` "поворачивает ключ" и запускает сервер, который начинает "слушать" входящие запросы.
7.  **Красивое завершение:** Регистрируются обработчики `SIGINT` и `SIGTERM`, чтобы при остановке сервера (например, по `Ctrl+C`) выводилось красивое прощальное сообщение.

---

## 40. `backend/tsconfig.json` — Правила для "Учителя" на Сервере

Этот файл является локальным "учебником" для TypeScript, который уточняет правила специально для бэкенда.

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "dist",
    "paths": {
      "@scripts/*": ["../scripts/*"]
    }
  },
  "include": ["**/*"]
}
Use code with caution.
Markdown
"extends": "../tsconfig.json": Наследует все базовые правила из корневого tsconfig.json.
"compilerOptions.module": "commonjs": Ключевое отличие от фронтенда. Эта опция говорит TypeScript компилировать код в формат CommonJS (require/module.exports), который является стандартом для Node.js и Express.
"compilerOptions.outDir": "dist": Указывает, что при сборке проекта все скомпилированные .js файлы должны помещаться в папку dist.
"compilerOptions.paths": Настраивает "псевдонимы" для путей, например, @scripts/*, чтобы мы могли использовать красивые импорты, как и в админке.
"include": ["**/*"]: Указывает, что правила применяются ко всем файлам внутри папки backend.


---
---

# Часть X: Папка `scripts` — "Инструменты для Мастерской"

В этой папке лежат небольшие вспомогательные скрипты на TypeScript, которые могут использоваться в разных частях нашего монорепозитория.

## `scripts/printServerStop.ts`

Этот скрипт экспортирует простую функцию, которая выводит в консоль красивый баннер при остановке сервера. Он используется в `backend/index.ts` для обработки события `Ctrl+C`.


---

## 41. `backend/routes/auth.ts` — "Паспортный Стол"

Этот файл отвечает за все маршруты, связанные с аутентификацией и регистрацией. Это одна из самых важных и критичных для безопасности частей бэкенда.

### Маршрут `POST /api/auth/login`

*   **Назначение:** Проверяет email и пароль пользователя и, в случае успеха, возвращает JWT-токен.
*   **Ключевые фичи безопасности:**
    1.  **Rate Limiting:** Реализована простая, но эффективная защита от подбора пароля (брутфорс-атак). Ограничивается количество неудачных попыток входа с одного IP-адреса.
    2.  **Безопасное сравнение паролей:** Используется `bcrypt.compare` для сравнения хэшей паролей, что защищает от "атак по времени".
    3.  **Универсальные сообщения об ошибках:** В случае неверного логина или пароля возвращается одно и то же сообщение, чтобы злоумышленник не мог определить, что именно он ввел неправильно.
    4.  **Подробное логирование:** Все успешные и неуспешные попытки входа логируются на сервере.

### Маршрут `POST /api/auth/register`

*   **Назначение:** Создает нового пользователя.
*   **Ключевые фичи безопасности:**
    1.  **Валидация данных:** Проверяется наличие всех полей, корректность email и минимальная длина пароля.
    2.  **Хэширование паролей:** Перед сохранением в "базу данных" пароль хэшируется с помощью `bcrypt.hash`. **Никогда не храните пароли в открытом виде!**
    3.  **Проверка на дубликаты:** Проверяется, не существует ли уже пользователя с таким email.

> **📝 Заметка на будущее (потенциальное улучшение):**
> 1.  **Абстракция работы с БД:** Всю логику прямого чтения/записи файла `users.json` следует вынести в отдельный модуль-репозиторий (например, `db/userRepository.ts`), который будет предоставлять простые методы (`getUserByEmail`, `createUser`).
> 2.  **Секреты в `.env`:** Секретный ключ для JWT (`JWT_SECRET`) должен быть вынесен в переменные окружения и быть сложным и уникальным для продакшен-среды.

---

## 42. `backend/middlewares/authMiddleware.ts` — Служба Безопасности

Этот файл содержит **middleware** — функции-"охранники", которые встраиваются в цепочку обработки запроса и выполняют проверку **до** того, как запрос дойдет до основной логики. Здесь реализована двухуровневая система безопасности.

### Уровень 1: `requireAuth` — "Охранник на входе"
Эта функция — наш главный "фейс-контроль".

*   **Задача:** Проверить наличие и подлинность JWT-токена в заголовке `Authorization`.
*   **Как работает:**
    1.  Извлекает токен из заголовка.
    2.  Использует `jwt.verify()` для проверки подписи и срока действия токена.
    3.  Если токен валиден, она **"прикрепляет" к объекту запроса `req` данные о пользователе** (`req.user = payload`). Это позволяет последующим обработчикам знать, какой пользователь отправил запрос.
    4.  Если токен невалиден, она немедленно прерывает цепочку и отправляет ошибку `401` или `403`.

### Уровень 2: `requireRole` и `ensureSuperAdmin` — "Охранники на этажах"
Эта система реализует **контроль доступа на основе ролей (RBAC)**.

*   **`requireRole(role)`**: Это **"фабрика охранников"**. Она создает middleware, которое проверяет, совпадает ли роль пользователя (из `req.user.role`) с требуемой.
*   **`ensureSuperAdmin`**: Это конкретный "охранник", созданный фабрикой, который пропускает только пользователей с ролью `superadmin`.

> **📝 Заметка на будущее (потенциальное улучшение):**
> 1.  **Типизация `req.user`:** Вместо `(req as any).user` можно глобально расширить тип `Request` из Express, чтобы TypeScript "знал" о существовании `req.user` во всем приложении.
> 2.  **Централизация `JWT_SECRET`:** Секретный ключ дублируется здесь и в `auth.ts`. Его стоит вынести в единый конфигурационный файл или модуль.

---

## 43. `backend/routes/users.ts` — "Архив Личных Дел"

Этот файл реализует полный набор **CRUD-операций (Create, Read, Update, Delete)** для пользователей.

### Ключевые особенности:

*   **Защита маршрутов:** Все "опасные" операции (создание, удаление, изменение) защищены middleware `requireRole("admin")`, что гарантирует, что только администратор может управлять пользователями.
*   **Прямая работа с ФС:** Вся логика для чтения и записи данных находится прямо в обработчиках маршрутов, используя `readFileSync` и `writeFileSync`.
*   **Дублирование логики:** Логика валидации и создания пользователя частично дублируется с маршрутом `/register` из `auth.ts`.
*   **Сложный `PUT`-метод:** Маршрут `PUT /api/users/:id` является "комбайном", который отвечает за обновление всех полей пользователя, включая пароль.

> **📝 Заметка на будущее (Крупный Рефакторинг):**
> Этот файл — главный кандидат на рефакторинг с целью **абстрагирования работы с данными** и **упрощения логики**.
> 1.  **Создание Репозитория:** Всю логику `readFileSync`/`writeFileSync` и поиска/фильтрации пользователей следует вынести в отдельный класс или объект-репозиторий (например, `db/userRepository.ts`). Обработчики маршрутов должны будут вызывать простые методы, такие как `userRepository.getAll()`, `userRepository.update(id, data)`.
> 2.  **Создание Сервисного слоя:** Логику валидации (проверка email, пароля, дубликатов) можно вынести в "сервисный слой" (например, `services/userService.ts`), чтобы она не дублировалась в разных маршрутах.
> 3.  **Разделение `PUT`-метода:** Сложный маршрут обновления можно разбить на несколько более простых и безопасных:
>     *   `PUT /api/users/:id/profile` (для обновления имени, email)
>     *   `POST /api/users/:id/password` (для смены пароля)
>     *   `POST /api/users/:id/role` (для смены роли)

---

## 44. `backend/routes/upload.ts` — "Отдел Приема Посылок"

Этот файл отвечает за загрузку файлов (аватаров, изображений) на сервер. Он использует библиотеку `multer` для обработки `multipart/form-data` запросов.

### Маршрут `POST /api/upload`

*   **Middleware `multer`**: Маршрут использует `multer` как middleware. Это значит, что `multer` сначала перехватывает запрос, сохраняет файл на диск в папку `/uploads` с уникальным именем, и только потом передает управление основной логике.
*   **Безопасность**: Установлен лимит на размер файла (2MB) для предотвращения загрузки слишком больших файлов.
*   **Результат**: В случае успеха, маршрут возвращает JSON с публичным URL-адресом, по которому можно получить доступ к загруженному файлу.

> **📝 Заметка на будущее (потенциальное улучшение):**
> 1.  **Централизация `multer`:** Конфигурация `multer` сейчас дублируется и должна быть полностью перенесена в `middlewares/uploadMiddleware.ts`, чтобы избежать повторения кода.
> 2.  **Фильтрация файлов:** Следует добавить `fileFilter` в настройки `multer`, чтобы разрешать загрузку только определенных типов файлов (например, `image/jpeg`, `image/png`).
> 3.  **Переменные окружения:** Базовый URL для файлов (`http://localhost:3001`) должен быть вынесен в `.env` файл.


---

## 45. `backend/config/multer.ts` — "Чертежи" для Загрузчика Файлов

Этот файл является центральным конфигурационным файлом для библиотеки `multer`, которая отвечает за загрузку файлов.

### Что он делает:
*   **`storage`**: Определяет, куда и под каким именем сохранять файлы.
    *   **`destination`**: Указывает, что все файлы должны сохраняться в папку `uploads`.
    *   **`filename`**: Генерирует **полностью уникальное имя** для каждого файла с помощью библиотеки `uuid`. Это очень надежный способ, который предотвращает любые конфликты и перезапись файлов.
*   **`upload`**: Создает и экспортирует готовый к использованию экземпляр `multer` с заданной конфигурацией.

> Этот файл — пример **хорошей практики**, так как он выносит всю ло

---

## 46. `backend/routes/sites.ts` — "Диспетчерская Вышка"

Этот файл отвечает за управление контентом сайтов. Его ключевая особенность — разделение всей логики на **два отдельных роутера**:

1.  **`publicSitesRouter`**: Предоставляет **публичные** маршруты, доступные без авторизации. Они предназначены для клиентских сайтов и отдают только опубликованные данные (например, `GET /api/sites/:id/banner`).
2.  **`adminSitesRouter`**: Предоставляет **приватные** маршруты для админки. Все они защищены middleware `ensureSuperAdmin`, что гарантирует доступ только для администраторов.

### Ключевые паттерны:

*   **Разделение API:** Создание двух роутеров — это отличный паттерн, который повышает безопасность и делает код более организованным.
*   **Система Черновик/Публикация:** Для баннера реализована надежная система, позволяющая администратору сначала работать с черновиком (`draft`), а затем, по готовности, "публиковать" его (копировать в `published`). Маршрут для публики отдает только `published` версию, если не указан специальный флаг `?preview=true`.
*   **Динамическая работа с ФС:** Некоторые маршруты (например, для получения товаров) работают с файловой системой, используя `siteId` из URL для построения пути к файлу.

> **📝 Заметка на будущее (потенциальное улучшение):**
> 1.  **Абстракция работы с БД:** Как и в других файлах, всю логику `readFileSync`/`writeFileSync` следует вынести в отдельный репозиторий (`db/siteRepository.ts`), который будет инкапсулировать всю логику работы с файлами.
> 2.  **Безопасность динамических путей:** При работе с файловой системой на основе данных от пользователя (как `siteId`), необходимо внедрить механизм "санитизации" (очистки) этих данных, чтобы предотвратить уязвимости вроде "path traversal".

---

## 47. `backend/routes/products.ts` — Публичный Маршрут для Товаров

Этот файл определяет публичный маршрут `GET /api/sites/:siteId/products`, который предназначен для получения списка товаров для конкретного клиентского сайта.

### Как он работает:

1.  Маршрут читает один общий файл `db/products.json`, в котором хранятся товары для всех сайтов.
2.  Затем он фильтрует этот массив в памяти, чтобы выбрать только те товары, у которых `siteId` совпадает с запрошенным в URL.
3.  Отфильтрованный список возвращается клиенту.

> **📝 Заметка на будущее (потенциальное улучшение):**
> 1.  **Производительность:** Текущий подход (чтение и фильтрация всего файла) может стать узким местом при большом количестве товаров. В будущем, при переходе на настоящую базу данных, этот запрос будет выполняться гораздо эффективнее.
> 2.  **Абстракция работы с БД:** Как и в других файлах, логику работы с `products.json` следует вынести в отдельный репозиторий.

---

## 48. `backend/routes/pages.ts` — Публичный Маршрут для Страниц

Этот файл определяет публичный маршрут `GET /api/sites/:siteId/pages/:slug`. Его задача — отдать данные для одной конкретной страницы (например, "О компании") для определенного сайта.

### Как он работает:
Он работает по тому же принципу, что и `products.ts`:
1.  Читает один общий файл `db/pages.json`.
2.  Находит в нем одну запись, которая соответствует и `siteId`, и `slug` из URL.
3.  Возвращает найденную страницу или ошибку 404.

> Все те же рекомендации по улучшению производительности и выносу логики работы с файловой системой в отдельный репозиторий, что и для `products.ts`, применимы и здесь.


---

## 49. `backend/utils/paths.ts` — "Официальная Карта" Проекта

Этот файл является примером хорошей практики **централизации конфигурации**. Его единственная задача — определять и экспортировать абсолютные пути к важным директориям проекта.

*   **`uploadsPath`**: Содержит надежно сконструированный путь к папке `uploads`, куда сохраняются загруженные файлы.

**Зачем это нужно?**
Вместо того чтобы "зашивать" пути (`'../uploads'`) в разных частях кода (в `config`, в `routes`), мы импортируем их из этого одного файла. Если в будущем мы решим переименовать или переместить папку `uploads`, нам нужно будет внести изменение только в **одном** этом файле, а не искать все его упоминания по всему проекту.

---

## 50. Папка `backend/db` — "Хранилище Данных"

Эта папка — наша простая, файловая **база данных**. Вместо настоящей БД (вроде PostgreSQL или MongoDB), мы используем обычные `.json` файлы для хранения всей информации. Этот подход отлично подходит для прототипирования и небольших проектов.

### 50.1. `db/kyanchir/products.json` — "Картотека Товаров"

*   **Назначение:** Этот файл хранит **полный список товаров** для сайта "kyanchir".
*   **Структура:** Это JSON-массив, где каждый объект представляет собой один товар со всеми его свойствами (`id`, `name`, `price`, `imageUrl1` и т.д.).
*   **Роль в системе:** Этот файл является **"источником правды"** для всего, что связано с товарами. Маршруты из `routes/` читают данные из него, а редакторы из `admin/` в конечном итоге сохраняют данные в него.

> **📝 Заметка на будущее (Ключевое Улучшение):**
> Использование `.json` файлов в качестве базы данных — это отличное временное решение. Однако у него есть недостатки:
> 1.  **Производительность:** При большом количестве данных чтение и запись всего файла на каждый запрос становится очень медленным.
> 2.  **"Гонки" (Race Conditions):** Если два пользователя одновременно попытаются изменить файл, данные одного из них могут быть потеряны.
> 3.  **Сложность запросов:** Невозможно делать сложные выборки, сортировку или поиск без полного чтения файла.
>
> Поэтому, по мере роста проекта, **ключевым шагом будет миграция** с файловой "БД" на настоящую, полноценную базу данных (например, **PostgreSQL** для реляционных данных или **MongoDB** для документо-ориентированных).


---

## 51. `backend/db/pages.json` — "Инструкция по Сборке" Страниц

Этот файл — один из самых важных и мощных элементов архитектуры проекта. Он хранит не просто данные, а **структуру веб-страниц** в формате JSON. Это основа для системы **визуального конструирования (page builder)**.

### Как это работает:

Каждый объект в этом файле представляет собой одну страницу (например, "Главная"). Ключевое поле в нем — это массив `components`.

```json
"components": [
  {
    "type": "Header",
    "props": { ... }
  },
  {
    "type": "HeroSection",
    "props": { ... }
  }
]
Use code with caution.
Markdown
Этот массив — это, по сути, "инструкция по сборке" для фронтенда.
Клиентский сайт получает эту "инструкцию" и, пробегаясь по ней, динамически рендерит React-компоненты (Header, HeroSection и т.д.), передавая им соответствующие props.
Преимущества этого подхода:
Гибкость: Можно полностью менять структуру и содержимое страниц, просто изменяя JSON на бэкенде, без необходимости переделывать фронтенд-код.
Разделение ответственности: Бэкенд отвечает за структуру и данные, а фронтенд — за визуальное представление компонентов.
Это очень мощный паттерн, который используется в современных Headless CMS и конструкторах сайтов.


---

## 52. `backend/db/sites.json` — "Реестр Сайтов"

Этот файл является центральной "таблицей базы данных", в которой хранится **список всех сайтов**, созданных на платформе.

### Структура данных:

Каждый объект в этом файле представляет собой один сайт и содержит всю его мета-информацию:
*   Уникальный `id`.
*   Название (`name`) и домен (`domain`).
*   Статус (`status`), тарифный план (`plan`) и дату создания.
*   **`ownerUserId`**: Это ключевое поле, которое связывает сайт с его владельцем из файла `users.json`.

Этот файл является "источником правды" для маршрутов из `routes/sites.ts`, которые читают и изменяют его содержимое.


---

## 53. `backend/db/users.json` — "Личные Дела" Всех Пользователей

Этот файл является "сердцем" системы аутентификации и авторизации. В нем хранятся данные всех зарегистрированных пользователей платформы.

### Структура данных:

Каждый объект в этом файле представляет одного пользователя и содержит:
*   Уникальный `id`.
*   Email и **хэш пароля**. Важно помнить, что сам пароль никогда не хранится в открытом виде, только его хэш, который невозможно расшифровать.
*   Роль (`role`), определяющая уровень доступа пользователя (`superadmin`, `admin`, `editor` и т.д.).
*   URL аватара (`avatarUrl`, если он есть).

### Роль файла в системе:

*   **Аутентификация (`routes/auth.ts`):** При входе пользователя система сверяет введенный пароль с хэшем из этого файла.
*   **Авторизация (`middlewares/authMiddleware.ts`):** Информация о роли пользователя из этого файла используется для проверки прав доступа к защищенным маршрутам.
*   **Управление пользователями (`routes/users.ts`):** CRUD-операции для пользователей работают напрямую с этим файлом.
*   **Связь с сайтами:** Поле `ownerUserId` в `db/sites.json` ссылается на `id` пользователя в этом файле.

> **Безопасность:** Файл `users.json` является одним из самых чувствительных. Доступ к нему должен быть строго ограничен. Также крайне важно, чтобы `.gitignore` **исключал** этот файл из системы контроля версий, чтобы случайно не опубликовать хэши паролей. (Напомню, что мы это сделали!).

---

## 54. Удаленные Артефакты (Часть 3): Устаревший Middleware `/middlewares/auth.ts`

В ходе ревизии мы обнаружили и удалили файл `auth.ts` из папки `middlewares`.

**Что это было:**
Файл содержал очень простую, устаревшую функцию `requireAuth`, которая проверяла наличие в заголовке `Authorization` жестко "зашитого" токена (`"secret_token_123"`).

**Почему он был удален:**
*   **Неиспользуемый код:** Эта функция не использовалась ни в одном из маршрутов бэкенда.
*   **Устаревшая логика:** Современная система авторизации в проекте основана на JWT-токенах, обрабатываемых файлом `authMiddleware.ts`. Старый middleware был неактуален и мог вводить в заблуждение.

Удаление этого файла сделало код чище и устранило потенциальный источник путаницы.

---

## 55. `backend/middlewares/uploadMiddleware.ts` — "Профессиональный Грузчик"

Этот файл содержит middleware-функцию, которая использует настроенный инструмент `multer` для обработки загрузки одного файла.

*   **`export const uploadSingleImage = upload.single("file");`**: Эта строка создает и экспортирует готовый middleware, который:
    *   Перехватывает входящий запрос.
    *   Ищет в нем файл, отправленный с именем поля `"file"`.
    *   Применяет к нему все правила, заданные в `config/multer.ts` (место сохранения, генерация имени файла, лимиты размера).
    *   Добавляет информацию о загруженном файле в объект `req.file`.

**Важность:** Этот подход позволяет избежать дублирования логики настройки `multer` и использовать один и тот же "грузчик" в разных маршрутах, если потребуется.

---

## 42. `backend/package.json` — Паспорт Бэкенда

Этот файл — "паспорт" нашей серверной части. Он описывает:
*   Название проекта (`name`) и его версию (`version`).
*   Используемый пакетный менеджер (`packageManager`), который мы синхронизировали для всего проекта.
*   Настройки модулей (`type: "module"` или `commonjs`).
*   **Скрипты (`scripts`):** Здесь описаны команды для запуска сервера (`dev`), сборки (`build`) и других полезных действий.
*   **Зависимости (`dependencies`):** Список библиотек, которые НЕОБХОДИМЫ для работы бэкенда на сервере (Express, JWT, Bcrypt, Multer).
*   **Зависимости для разработки (`devDependencies`):** Инструменты, которые нужны только разработчикам (TypeScript, `tsx`, `@types/*`).

> **Ключевые зависимости:** `express` для создания API, `jsonwebtoken` для аутентификации, `bcryptjs` для безопасного хранения паролей, `multer` для загрузки файлов.

Добавь эту библиотеку всем оркестрам в нашем музыкальном доме (монорепозитории)!".
pnpm add git-rev-sync: Это команда установки.
-w (или --workspace): Это магический флаг, который говорит pnpm: "Сделай это для всех пакетов, которые являются частью нашего монорепозитория".
---

## 46. `backend/config/multer.ts` — "Чертежи" для Загрузчика Файлов

Этот файл является центральной конфигурацией для библиотеки `multer`, которая обрабатывает загрузку файлов на сервер.

### Настройка `multer`:

*   **`storage`**: Определяет, как файлы будут сохраняться.
    *   **`destination`**: Указывает папку (`uploadsPath`), куда будут сохраняться все файлы.
    *   **`filename`**: Задает имя файла. Используется `uuidv4()` для генерации уникального имени, что предотвращает перезапись и коллизии.
*   **`upload`**: Создает экземпляр `multer`, настроенный с помощью `storage`, который затем экспортируется и используется в маршрутах.

> **Преимущество:** Вся логика обработки файлов централизована здесь, что делает код чище и позволяет легко управлять правилами загрузки (например, добавить валидацию типа файла в будущем).

---

## 58. `scripts/printAdminBanner.ts` — Приветствие в Админке

Этот скрипт отвечает за вывод информационного баннера в консоль при запуске админ-панели. Он читает `package.json` админки и форматирует важные сведения (название, описание, версию) в красивый баннер.

> **Использование:** Эта функция импортируется и вызывается в `vite.config.ts` админки, чтобы при запуске `pnpm dev` администратор видел стартовое сообщение.
Use code with caution.
Markdown
КОПИРУЙ ЭТОТ БЛОК (ДЛЯ dev.ts):
Generated markdown
---

## 59. `scripts/dev.ts` — "Главный Запуск" Всего Проекта

Этот скрипт автоматизирует запуск всех частей нашего монорепозитория в режиме разработки.

### Как он работает:

*   **`run(label, path)`**: Функция, которая запускает команду `pnpm run dev` для указанного проекта (например, `backend` или `admin`).
*   **`processes`**: `Set` для хранения всех запущенных процессов, чтобы потом ими управлять.
*   **`process.on("SIGINT")`**: Обработчик сигнала `Ctrl+C`. При нажатии `Ctrl+C` он корректно останавливает ВСЕ запущенные под-процессы.

> **Назначение:** Этот скрипт очень удобен, чтобы одним действием запустить все серверы и приложения, необходимые для локальной разработки.
>
> **❗️ Важно:** В скрипте была удалена строка, запускающая `apps/kyanchir`, так как эта папка была удалена.


БЛОК 1: Для routes/products.ts
Generated markdown
---

## 48. `backend/routes/products.ts` — Публичный Маршрут для Товаров

Этот файл определяет публичный маршрут `GET /api/sites/:siteId/products`, который предназначен для получения списка товаров для конкретного клиентского сайта.

### Как он работает:
Он работает по тому же принципу, что и `pages.ts`:
1.  Читает один общий файл `db/products.json`.
2.  Находит в нем записи, которые соответствуют `siteId` из URL.
3.  Возвращает найденные товары или ошибку 404.

> **📝 Заметка на будущее (потенциальное улучшение):**
> 1.  **Производительность:** Текущий подход (чтение и фильтрация всего файла) может стать узким местом при большом количестве товаров. В будущем, при переходе на настоящую базу данных, этот запрос будет выполняться гораздо эффективнее.
> 2.  **Абстракция работы с БД:** Как и в других файлах, логику работы с `products.json` следует вынести в отдельный репозиторий.
Use code with caution.
Markdown
БЛОК 2: Для routes/sites.ts
Generated markdown
---

## 49. `backend/routes/sites.ts` — "Диспетчерская Вышка" Управления Сайтами

Этот файл отвечает за управление контентом сайтов. Его ключевая особенность — разделение всей логики на **два отдельных роутера**:

1.  **`publicSitesRouter`**: Предоставляет **публичные** маршруты, доступные без авторизации. Они предназначены для клиентских сайтов и отдают только опубликованные данные (например, `GET /api/sites/:id/banner`).
2.  **`adminSitesRouter`**: Предоставляет **приватные** маршруты для админки. Все они защищены middleware `ensureSuperAdmin`, что гарантирует доступ только для администраторов.

### Ключевые паттерны:

*   **Разделение API:** Создание двух роутеров — это отличный паттерн, который повышает безопасность и делает код более организованным.
*   **Система Черновик/Публикация:** Для баннера реализована надежная система, позволяющая администратору сначала работать с черновиком (`draft`), а затем, по готовности, "публиковать" его (копировать в `published`). Маршрут для публики отдает только `published` версию, если не указан специальный флаг `?preview=true`.
*   **Динамическая работа с ФС:** Некоторые маршруты (например, для получения товаров) работают с файловой системой, используя `siteId` из URL для построения пути к файлу.

> **📝 Заметка на будущее (потенциальное улучшение):**
> 1.  **Абстракция работы с БД:** Как и в других файлах, всю логику `readFileSync`/`writeFileSync` следует вынести в отдельный репозиторий (`db/siteRepository.ts`), который будет инкапсулировать всю логику работы с файлами.
> 2.  **Безопасность динамических путей:** При работе с файловой системой на основе данных от пользователя (как `siteId`), необходимо внедрить механизм "санитизации" (очистки) этих данных, чтобы предотвратить уязвимости вроде "path traversal".
> 3.  **CRUD для Сайтов:** Необходимо добавить маршруты для создания (`POST`), обновления (`PUT`) и удаления (`DELETE`) самих сайтов.
> 4.  **CRUD для Товаров:** Аналогично, нужны полные CRUD-операции для товаров, а не только получение черновика.
Use code with caution.
Markdown
И еще:
Ты указал на routes/users.ts, который мы разобрали, но я не добавил ему документацию в путеводитель. Сейчас добавим.
БЛОК 3: Для routes/users.ts
Generated markdown
---

## 43. `backend/routes/users.ts` — "Архив Личных Дел"

Этот файл реализует полный набор **CRUD-операций (Create, Read, Update, Delete)** для пользователей.

### Ключевые особенности:

*   **Защита маршрутов:** Все "опасные" операции (создание, удаление, изменение) защищены middleware `requireRole("admin")`, что гарантирует, что только администратор может управлять пользователями.
*   **Прямая работа с ФС:** Вся логика для чтения и записи данных находится прямо в обработчиках маршрутов, используя `readFileSync` и `writeFileSync`.
*   **Дублирование логики:** Логика валидации и создания пользователя частично дублируется с маршрутом `/register` из `auth.ts`.
*   **Сложный `PUT`-метод:** Маршрут `PUT /api/users/:id` является "комбайном", который отвечает за обновление всех полей пользователя, включая пароль.

> **📝 Заметка на будущее (Крупный Рефакторинг):**
> Этот файл — главный кандидат на рефакторинг с целью **абстрагирования работы с данными** и **упрощения логики**.
> 1.  **Создание Репозитория:** Всю логику `readFileSync`/`writeFileSync` и поиска/фильтрации пользователей следует вынести в отдельный класс или объект-репозиторий (например, `db/userRepository.ts`). Обработчики маршрутов должны будут вызывать простые методы, такие как `userRepository.getAll()`, `userRepository.update(id, data)`.
> 2.  **Создание Сервисного слоя:** Логику валидации (проверка email, пароля, дубликатов) можно вынести в "сервисный слой" (например, `services/userService.ts`), чтобы она не дублировалась в разных маршрутах.
> 3.  **Разделение `PUT`-метода:** Сложный маршрут обновления можно разбить на несколько более простых и безопасных:
>     *   `PUT /api/users/:id/profile` (для обновления имени, email)
>     *   `POST /api/users/:id/password` (для смены пароля)
>     *   `POST /api/users/:id/role` (для смены роли)

---

## 56. `packages/core/utils/slugify.ts` — "Преобразователь Имён"

Эта утилита отвечает за преобразование обычного текста в "слаг" — безопасную для использования в URL строку.

### Как это работает:

Функция `slugify` выполняет несколько шагов для очистки и нормализации строки:
1.  Приводит текст к нижнему регистру.
2.  Удаляет диакритические знаки (например, `é` становится `e`).
3.  Заменяет пробелы на дефисы.
4.  Удаляет все символы, кроме букв, цифр и дефисов.
5.  Очищает множественные дефисы и дефисы по краям строки.

> **Применение:** Такая функция очень полезна для генерации URL-адресов страниц (`slug`), идентификаторов сайтов (`siteId`) или любых других имен, которые должны быть безопасны для использования в URL.

---

## 58. `packages/ui/src/utils/formatPrice.ts` — Форматировщик Цен

Этот файл содержит полезную утилиту для форматирования числовых значений цены в более читаемый вид.

```typescript
export function formatPrice(price: number | null | undefined): PriceParts | null {
  // ... (логика форматирования)
}

---

## 59. `packages/ui/package.json` — Паспорт UI-Библиотеки

Этот файл описывает "паспорт" нашего UI-модуля — набора переиспользуемых компонентов.

### Ключевые моменты:

*   **`name: "@nabludatel/ui"`**: Указывает, что это пакет наших собственных UI-компонентов.
*   **`peerDependencies`**: Очень важная секция. Она перечисляет зависимости (`react`, `react-dom`), которые **ожидаются** в проекте, использующем этот UI-пакет, но **не устанавливаются** напрямую здесь. Это позволяет избежать конфликтов версий React.
*   **`devDependencies`**: Включает TypeScript и его типы для React, необходимые для сборки библиотеки.
*   **`scripts.build: "tsc"`**: Команда для сборки TypeScript-кода в JavaScript.

> **Роль:** Этот пакет содержит переиспользуемые UI-элементы (например, кнопки, инпуты, шапки), которые используются в других частях проекта (админка, возможно, и клиентские сайты).
Use code with caution.
Markdown
КОПИРУЙ ЭТОТ БЛОК (для packages/ui/tsconfig.json):
Generated markdown
---

## 60. `packages/ui/tsconfig.json` — "Учебник" для UI-Библиотеки

Этот файл содержит настройки TypeScript, специфичные для нашего UI-пакета. Он используется для сборки библиотеки компонентов.

### Ключевые настройки:

*   **`extends: "../../tsconfig.json"`**: Наследует общие правила из корневого `tsconfig.json`.
*   **`compilerOptions`**:
    *   **`composite: true`, `declaration: true`, `declarationMap: true`**: Эти опции критически важны для сборки библиотеки. Они говорят TypeScript: "Собери код, создай файлы `.d.ts` (описания типов) и карты к ним, чтобы другие проекты могли легко использовать эту библиотеку".
    *   **`outDir: "dist"`, `rootDir: "src"`**: Определяют, где лежат исходники (`src`) и куда складывать собранный код (`dist`).
    *   **`module: "NodeNext"`, `moduleResolution: "NodeNext"`**: Используются современные настройки модулей.
    *   **`jsx: "react-jsx"`**: Корректная работа с JSX.
*   **`include: ["src"]`**: Применяет правила только к исходному коду.
*   **`references`**: `[{ "path": "../core" }]` — **Очень важная связь!** Эта секция говорит TypeScript: "При сборке этого UI-пакета, не забудь также учесть код из пакета `core`". Это связывает наши пакеты и обеспечивает правильный порядок сборки.

---

## 58. `packages/ui/src/design-system.css` — Основа Дизайн-Системы

Этот файл является центральным местом, где определяются все **базовые стили и CSS-переменные**, составляющие основу нашей дизайн-системы.

### Ключевые элементы:

*   **Импорт шрифтов:** Подключаются шрифты `Manrope`, `Unbounded` и `PT Mono` из Google Fonts.
*   **`@layer base`**: Определяет, что стили в этом блоке имеют низкий приоритет и служат базой.
*   **`:root` и CSS-переменные:** Здесь задаются все основные цвета (`--color-*`) и названия шрифтов (`--font-*`), которые затем используются в `tailwind.config.js` и других компонентах. Этот подход делает управление темами (например, светлой/темной) и изменение дизайна очень гибким.
*   **Базовые стили `body`:** К тегу `<body>` применяются базовые стили: шрифт по умолчанию, цвет текста и фоновый цвет.